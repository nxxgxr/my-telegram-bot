import os
import logging
import secrets
import requests
import base64
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime, timezone, timedelta
from threading import Thread
from flask import Flask, jsonify
import tempfile

# --- Settings ---

BOT_TOKEN = os.environ.get("BOT_TOKEN")
CRYPTOBOT_API_TOKEN = os.environ.get("CRYPTOBOT_API_TOKEN")
SPREADSHEET_NAME = os.environ.get("SPREADSHEET_NAME")
GOOGLE_CREDS_JSON_BASE64 = os.environ.get("GOOGLE_CREDS_JSON_BASE64")
CREDS_FILE = os.path.join(tempfile.gettempdir(), "google_creds.json")
SCOPE = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive",
]
CRYPTO_BOT_API = "https://pay.crypt.bot/api"

# Validate environment variables
REQUIRED_ENV_VARS = ["BOT_TOKEN", "CRYPTOBOT_API_TOKEN", "SPREADSHEET_NAME"]
for var in REQUIRED_ENV_VARS:
    if not os.environ.get(var):
        raise ValueError(f"Missing required environment variable: {var}")

# --- Logging ---

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Flask for keep-alive ---

app = Flask(__name__)

@app.route('/')
def home():
    return "‚úÖ Valture bot is running!"

def run_flask():
    port = int(os.environ.get("PORT", 8080))
    app.run(host="0.0.0.0", port=port)

# --- Google Sheets Setup ---

sheet_cache = None

def setup_google_creds():
    """Decode base64 Google credentials and create a temporary file."""
    logger.debug("Setting up Google credentials...")
    if GOOGLE_CREDS_JSON_BASE64:
        try:
            creds_json = base64.b64decode(GOOGLE_CREDS_JSON_BASE64).decode("utf-8")
            with open(CREDS_FILE, "w") as f:
                f.write(creds_json)
            logger.info("Google credentials saved to temporary file")
        except Exception as e:
            logger.error(f"Error decoding Google credentials: {e}")
            raise
    elif not os.path.exists(CREDS_FILE):
        logger.error("Google credentials file not found, and GOOGLE_CREDS_JSON_BASE64 is not set")
        raise FileNotFoundError("Google credentials file not found")

def get_sheet():
    """Get cached Google Sheets object."""
    global sheet_cache
    if sheet_cache is None:
        try:
            setup_google_creds()
            creds = Credentials.from_service_account_file(CREDS_FILE, scopes=SCOPE)
            client = gspread.authorize(creds)
            sheet_cache = client.open(SPREADSHEET_NAME).sheet1
            logger.info("Successfully connected to Google Sheets")
        except Exception as e:
            logger.error(f"Error connecting to Google Sheets: {e}")
            raise
    return sheet_cache

def append_license_to_sheet(license_key: str, username: str):
    """Append license key to Google Sheets."""
    try:
        sheet = get_sheet()
        utc_plus_2 = timezone(timedelta(hours=2))
        now_utc_plus_2 = datetime.now(utc_plus_2)
        now_str = now_utc_plus_2.strftime("%Y-%m-%d %H:%M:%S")
        sheet.append_row([license_key, "", username, now_str])
        logger.info(f"License {license_key[:8]}... added for {username}")
    except Exception as e:
        logger.error(f"Error appending license: {e}")
        raise

def generate_license(length: int = 32) -> str:
    """Generate a secure license key."""
    try:
        key = ''.join(secrets.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in range(length))
        logger.info(f"Generated license key (first 8 chars): {key[:8]}...")
        return key
    except Exception as e:
        logger.error(f"Error generating key: {e}")
        raise

# --- CryptoBot Payment Functions ---

def get_pay_link(amount: str) -> tuple[str, str]:
    """Create a CryptoBot invoice and return the payment link and invoice ID."""
    headers = {"Crypto-Pay-API-Token": CRYPTOBOT_API_TOKEN}
    data = {
        "asset": "TON",
        "amount": amount,
        "description": "Valture License"
    }
    try:
        response = requests.post(f"{CRYPTO_BOT_API}/createInvoice", headers=headers, json=data, timeout=10)
        response.raise_for_status()
        response_data = response.json()
        return response_data['result']['pay_url'], response_data['result']['invoice_id']
    except requests.RequestException as e:
        logger.error(f"Error creating invoice: {e}")
        return None, None

def check_payment_status(invoice_id: str) -> dict:
    """Check the status of a CryptoBot invoice."""
    headers = {
        "Crypto-Pay-API-Token": CRYPTOBOT_API_TOKEN,
        "Content-Type": "application/json"
    }
    try:
        response = requests.post(f"{CRYPTO_BOT_API}/getInvoices", headers=headers, json={}, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        logger.error(f"Error checking payment status: {e}")
        return None

# --- Telegram Bot Logic ---

def get_keyboard(buttons: list) -> InlineKeyboardMarkup:
    """Create an inline keyboard."""
    return InlineKeyboardMarkup([[InlineKeyboardButton(text, callback_data=callback)] for text, callback in buttons])

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Welcome message."""
    welcome_text = (
        "üéÆ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Valture!*\n\n"
        "–í–∞—à –ª—É—á—à–∏–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –∏–≥—Ä–æ–≤–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏! üöÄ\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å:"
    )
    buttons = [("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "menu_main")]
    await update.message.reply_text(welcome_text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Main menu without 'Back' button."""
    query = update.callback_query
    await query.answer()
    buttons = [
        ("‚ÑπÔ∏è –û Valture", "menu_about"),
        ("üì∞ –ù–æ–≤–æ—Å—Ç–∏", "menu_news"),
        ("üí≥ –ö—É–ø–∏—Ç—å –ª–∏—Ü–µ–Ω–∑–∏—é", "menu_pay"),
        ("‚ùì FAQ", "menu_faq"),
        ("üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", "menu_support"),
    ]
    await query.edit_message_text(
        "üè† *–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é*\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:",
        parse_mode="Markdown",
        reply_markup=get_keyboard(buttons)
    )

async def about(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """About section with 'Back' button."""
    query = update.callback_query
    await query.answer()
    text = (
        "‚ú® *Valture ‚Äî –í–∞—à –ø—É—Ç—å –∫ —Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤—É –≤ –∏–≥—Ä–∞—Ö*\n\n"
        "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        "Valture ‚Äî —ç—Ç–æ –ø–µ—Ä–µ–¥–æ–≤–æ–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, —Å–æ–∑–¥–∞–Ω–Ω—ã–π –¥–ª—è –≥–µ–π–º–µ—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –≥–æ—Ç–æ–≤—ã –º–∏—Ä–∏—Ç—å—Å—è —Å –∫–æ–º–ø—Ä–æ–º–∏—Å—Å–∞–º–∏. "
        "–ù–∞—à–∞ –º–∏—Å—Å–∏—è ‚Äî –≤—ã–≤–µ—Å—Ç–∏ –≤–∞—à—É –∏–≥—Ä–æ–≤—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–∞ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å, –æ–±–µ—Å–ø–µ—á–∏–≤ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø–ª–∞–≤–Ω–æ—Å—Ç—å, "
        "—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –∏ –æ—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã. –° Valture –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ, –æ –∫–æ—Ç–æ—Ä–æ–º –≤—Å–µ–≥–¥–∞ –º–µ—á—Ç–∞–ª–∏.\n\n"
        "üî• *–ü–æ—á–µ–º—É –≤—ã–±–∏—Ä–∞—é—Ç Valture?*\n"
        "üöÄ –£–≤–µ–ª–∏—á–µ–Ω–∏–µ FPS –Ω–∞ 20‚Äì30%: –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º—ã, —á—Ç–æ–±—ã –¥–æ–±–∏—Ç—å—Å—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —á–∞—Å—Ç–æ—Ç—ã –∫–∞–¥—Ä–æ–≤.\n"
        "üõ°Ô∏è –°—Ç–∞–±–∏–ª—å–Ω—ã–π —Ñ—Ä–µ–π–º—Ä–µ–π—Ç: –ó–∞–±—É–¥—å—Ç–µ –æ –ª–∞–≥–∞—Ö –∏ –ø—Ä–æ—Å–∞–¥–∫–∞—Ö FPS ‚Äî Valture –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–ª–∞–≤–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π –ø—Ä–æ—Ü–µ—Å—Å.\n"
        "üí° –ú–æ–ª–Ω–∏–µ–Ω–æ—Å–Ω–∞—è –æ—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç—å: –°–æ–∫—Ä–∞—Ç–∏—Ç–µ –≤—Ä–µ–º—è –æ—Ç–∫–ª–∏–∫–∞ —Å–∏—Å—Ç–µ–º—ã, —á—Ç–æ–±—ã –∫–∞–∂–¥—ã–π –≤–∞—à –∫–ª–∏–∫ –∏–ª–∏ –¥–≤–∏–∂–µ–Ω–∏–µ –±—ã–ª–∏ –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–º–∏.\n"
        "üîã –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è Windows: –ü–æ–ª–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ –∏–≥—Ä–∞—Ö.\n"
        "üõ≥Ô∏è  –ü–ª–∞–≤–Ω–æ—Å—Ç—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è: –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å –∏ —á–µ—Ç–∫–æ—Å—Ç—å –º—ã—à–∏ –¥–ª—è –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è –≤ –ª—é–±–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏.\n"
        "üñ•Ô∏è  –ü–ª–∞–≤–Ω–æ—Å—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫–∏ –≤ –∏–≥—Ä–∞—Ö: –ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å —á–µ—Ç–∫–æ–π –∏ –ø–ª–∞–≤–Ω–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–æ–π, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–≥—Ä—É–∂–∞–µ—Ç –≤–∞—Å –≤ –∏–≥—Ä—É.\n\n"
        "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        "_–°–æ–∑–¥–∞–Ω–æ –¥–ª—è –≥–µ–π–º–µ—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ü–µ–Ω—è—Ç –∫–∞—á–µ—Å—Ç–≤–æ –∏ —Å—Ç—Ä–µ–º—è—Ç—Å—è –∫ –ø–æ–±–µ–¥–µ._"
    )
    buttons = [("üîô –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "menu_main")]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def pay(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Payment menu with updated price and 'Back' button."""
    query = update.callback_query
    await query.answer()
    text = (
        "üí≥ *–ü–æ–∫—É–ø–∫–∞ –ª–∏—Ü–µ–Ω–∑–∏–∏ Valture*\n\n"
        "–¶–µ–Ω–∞: *4 TON*\n"
        "–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ CryptoBot.\n\n"
        "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç –∏ –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω—ã–π –∫–ª—é—á."
    )
    buttons = [
        ("üí∏ –û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ CryptoBot", "pay_crypto"),
        ("üîô –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "menu_main")
    ]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def pay_crypto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Initiate CryptoBot payment."""
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    username = query.from_user.username or query.from_user.full_name

    try:
        pay_link, invoice_id = get_pay_link('4')
        if pay_link and invoice_id:
            context.user_data["invoice_id"] = str(invoice_id)
            context.user_data["username"] = username
            context.user_data["chat_id"] = chat_id
            logger.info(f"CryptoBot invoice created: invoice_id={invoice_id}")
            text = (
                "üí∏ *–û–ø–ª–∞—Ç–∏—Ç–µ —á–µ—Ä–µ–∑ CryptoBot*\n\n"
                "–ù–∞–∂–º–∏—Ç–µ –Ω–∏–∂–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã *4 TON*:\n"
                f"[–û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ CryptoBot]({pay_link})\n\n"
                "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É'."
            )
            buttons = [
                ("‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É", f"check_payment_{invoice_id}"),
                ("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–æ—Å–æ–±–∞–º –æ–ø–ª–∞—Ç—ã", "menu_pay")
            ]
            await query.edit_message_text(
                text,
                parse_mode="Markdown",
                reply_markup=get_keyboard(buttons),
                disable_web_page_preview=True
            )
        else:
            text = (
                "‚ùå *–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—á–µ—Ç –Ω–∞ –æ–ø–ª–∞—Ç—É!*\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å @s3pt1ck."
            )
            buttons = [
                ("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", "pay_crypto"),
                ("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–æ—Å–æ–±–∞–º –æ–ø–ª–∞—Ç—ã", "menu_pay")
            ]
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))
    except Exception as e:
        logger.error(f"Error initiating payment: {e}", exc_info=True)
        text = (
            "‚ùå *–û—à–∏–±–∫–∞!*\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å @s3pt1ck."
        )
        buttons = [
            ("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", "pay_crypto"),
            ("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–æ—Å–æ–±–∞–º –æ–ø–ª–∞—Ç—ã", "menu_pay")
        ]
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def check_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Check CryptoBot payment status."""
    query = update.callback_query
    await query.answer()
    chat_id = context.user_data.get("chat_id", query.message.chat_id)
    invoice_id = query.data.split('check_payment_')[1]
    username = context.user_data.get("username")

    if not username:
        logger.error("Username missing in context.user_data")
        text = (
            "‚ùå *–û—à–∏–±–∫–∞!*\n\n"
            "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å @s3pt1ck."
        )
        buttons = [
            ("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", "pay_crypto"),
            ("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–æ—Å–æ–±–∞–º –æ–ø–ª–∞—Ç—ã", "menu_pay")
        ]
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))
        return

    try:
        payment_status = check_payment_status(invoice_id)
        logger.debug(f"Checking payment for invoice_id={invoice_id}, response: {payment_status}")
        if payment_status and payment_status.get('ok'):
            if 'items' in payment_status['result'] and payment_status['result']['items']:
                invoice = next((inv for inv in payment_status['result']['items'] if str(inv['invoice_id']) == str(invoice_id)), None)
                if invoice:
                    status = invoice['status']
                    logger.debug(f"Invoice {invoice_id} status: {status}")
                    if status == 'paid':
                        license_key = generate_license()
                        append_license_to_sheet(license_key, username)
                        text = (
                            "üéâ *–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø–æ–∫—É–ø–∫–æ–π!*\n\n"
                            "–í–∞—à –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω—ã–π –∫–ª—é—á:\n"
                            f"`{license_key}`\n\n"
                            "–°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –≤ –Ω–∞–¥–µ–∂–Ω–æ–º –º–µ—Å—Ç–µ! üöÄ"
                        )
                        await query.edit_message_text(
                            text,
                            parse_mode="Markdown",
                            reply_markup=get_keyboard([("üè† –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "menu_main")])
                        )
                        try:
                            with open('qw.docx', 'rb') as document:
                                await context.bot.send_document(chat_id, document)
                            logger.info(f"Document sent to {username} (chat_id: {chat_id})")
                        except FileNotFoundError:
                            logger.error("Document 'qw.docx' not found")
                            await context.bot.send_message(
                                chat_id,
                                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç. –°–≤—è–∂–∏—Ç–µ—Å—å —Å @s3pt1ck."
                            )
                        context.user_data.clear()
                    else:
                        text = (
                            "‚è≥ *–û–ø–ª–∞—Ç–∞ –µ—â–µ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞*\n\n"
                            "–ó–∞–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞. –°–≤—è–∂–∏—Ç–µ—Å—å —Å @s3pt1ck, –µ—Å–ª–∏ –Ω—É–∂–Ω–∞ –ø–æ–º–æ—â—å."
                        )
                        buttons = [
                            ("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞", f"check_payment_{invoice_id}"),
                            ("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–æ—Å–æ–±–∞–º –æ–ø–ª–∞—Ç—ã", "menu_pay")
                        ]
                        await query.edit_message_text(
                            text,
                            parse_mode="Markdown",
                            reply_markup=get_keyboard(buttons)
                        )
                else:
                    logger.error(f"Invoice {invoice_id} not found in API response")
                    await query.answer("–°—á–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
            else:
                logger.error(f"API response missing 'items' or empty: {payment_status}")
                await query.answer("–û—à–∏–±–∫–∞: –û—Ç–≤–µ—Ç –æ—Ç API –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö –æ–± –æ–ø–ª–∞—Ç–µ.", show_alert=True)
        else:
            logger.error(f"Invalid API response: {payment_status}")
            await query.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –æ–ø–ª–∞—Ç—ã.", show_alert=True)
    except Exception as e:
        logger.error(f"Error verifying payment for invoice_id={invoice_id}: {e}", exc_info=True)
        text = (
            "‚ùå *–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫!*\n\n"
            "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å @s3pt1ck."
        )
        buttons = [
            ("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞", f"check_payment_{invoice_id}"),
            ("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–æ—Å–æ–±–∞–º –æ–ø–ª–∞—Ç—ã", "menu_pay")
        ]
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Support menu with 'Back' button."""
    query = update.callback_query
    await query.answer()
    text = (
        "üìû *–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å?*\n\n"
        "–°–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞—à–µ–π –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π:\n"
        "üëâ *@s3pt1ck*\n\n"
        "–ú—ã –æ—Ç–≤–µ—Ç–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –±—ã—Å—Ç—Ä–æ! üòä"
    )
    buttons = [("üîô –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "menu_main")]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def faq(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """FAQ with brief answers and 'Back' button."""
    query = update.callback_query
    await query.answer()
    text = (
        "‚ùì *–ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã*\n\n"
        "üîπ *–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –ª–∏—Ü–µ–Ω–∑–∏—é?*\n"
        "–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ '–ö—É–ø–∏—Ç—å –ª–∏—Ü–µ–Ω–∑–∏—é' –∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã.\n\n"
        "üîπ *–ß—Ç–æ –¥–µ–ª–∞—Ç—å, –µ—Å–ª–∏ –∫–ª—é—á –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç?*\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É @s3pt1ck.\n\n"
        "üîπ *–ú–æ–∂–Ω–æ –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–ª—é—á –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö?*\n"
        "–ù–µ—Ç, –∫–ª—é—á –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –æ–¥–Ω–æ–º—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É."
    )
    buttons = [("üîô –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "menu_main")]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def news(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """News section with 'Back' button."""
    query = update.callback_query
    await query.answer()
    text = (
        "üì∞ *–ù–æ–≤–æ—Å—Ç–∏ Valture*\n\n"
        "–°–ª–µ–¥–∏—Ç–µ –∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏!\n"
        "–ü–æ–∫–∞ –Ω–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π –Ω–µ—Ç. üìÖ"
    )
    buttons = [("üîô –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "menu_main")]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=get_keyboard(buttons))

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle button presses."""
    query = update.callback_query
    data = query.data
    await query.answer()

    if data == "menu_main":
        await main_menu(update, context)
    elif data == "menu_pay":
        await pay(update, context)
    elif data == "pay_crypto":
        await pay_crypto(update, context)
    elif data.startswith("check_payment_"):
        await check_payment(update, context)
    elif data == "menu_support":
        await support(update, context)
    elif data == "menu_faq":
        await faq(update, context)
    elif data == "menu_about":
        await about(update, context)
    elif data == "menu_news":
        await news(update, context)

if __name__ == "__main__":
    # Start Flask in a separate thread
    Thread(target=run_flask).start()

    # Start the bot
    application = Application.builder().token(BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_handler))

    logger.info("Valture bot started")
    application.run_polling()
